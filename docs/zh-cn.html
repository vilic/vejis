<!DOCTYPE html>

<html>
<head>
    <title>VEJIS - It's JavaScript!</title>
    <link href="main.css" rel="stylesheet" type="text/css" />
    <style type="text/css">
        #nav, #donate, #content_wrapper { font-family: Microsoft Yahei, Arial; }
    </style>
    <script src="main.js" type="text/javascript"></script>
    <script src="vlight.js" type="text/javascript"></script>
	<script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-25148472-1']);
    _gaq.push(['_setDomainName', 'vejis.org']);
    _gaq.push(['_setAllowHash', 'false']);
    _gaq.push(['_trackPageview']);

    (function () {
    	var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    	ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    	var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
	</script>
</head>
<body>
<div id="page_wrapper">
    <div id="header">
        <a id="logo" href="#">
            <span class="title">VEJIS</span>
            <span class="description">It's JavaScript!</span>
        </a>
        <div id="nav">
            <a class="current" href="#">简介</a>
            <!--
    	<a class="disabled" href="#">Get Started</a>
            <a class="disabled" href="#">Documentation</a>
            -->
    	<a href="http://www.vilic.info/">我的博客</a>
    	<a href="https://github.com/vilic/vejis">下载</a>
    	<a href="http://www.vilic.info/blog/works/vejis">反馈</a>
    	<a href="index.html">English</a>
        </div>
        <!--<a id="donate" href="#" onclick="alert('嗨, 谢啦! 但我还没准备好... 囧.')">捐赠</a>-->
        <div id="header_light"></div>
    </div>
    <div id="content_wrapper">
        <div class="title">VEJIS是什么</div>
        <div class="content">
            <p>VEJIS是一个从 "语法层面" 加强JavaScript的库. 通过VEJIS, 使用者可以轻松地创建并使用命名空间, 还有强大的VEJIS类.</p>
        </div>
        <div class="title">命名空间系统</div>
        <div class="content">
            <p>现在, JavaScript不再只是处理一些简单的AJAX工作, 你或许已经发现, 自己的代码越来越长. 我们期望有一种更好的方式来组织自己的代码.</p>
            <p>这也正是VEJIS可以带给我们的!</p>
            <p>VEJIS的命名空间系统提供了3中方法来创建, 加载和使用相关的文件和命名空间.</p>
<pre class="vlight">
//创建命名空间 "vilic".
namespace_('vilic', function () {
    this.test = function () { };
});

//现在, 我们知道上面的命名空间 "vilic" 和方法 "test" 已经创建好了,
//所以, 让我们调用 "test" 方法.
vilic.test();

//但有时候, 要知道一个命名空间是否已经创建好却不是那么容易,
//不过, 使用 "use_" 就可以了.
use_('vilic', function (vilic) {
    vilic.test();
});

//那当我们需要的命名空间在其他的文件里呢?
//试试这样.
require_('vilic.alpha.js', function (alpha) {
    //一些代码.
});
</pre>
            <p>就像你看到的, 这3个方法是 "namespace_", "use_" 和 "require_", 或许你会想知道更多它们的使用方式.</p>
            <ul>
                <li>
                    <b>namespace_(name : string, body : function)</b><br />
                    <p>创建一个命名空间. 一个命名空间只有当它的父命名空间被创建后才会被创建. 比如, 命名空间 "vejis.alpha" 只有当命名空间 "vejis" 被创建后才会被创建. 否则, 它会被加入一个队列, 一旦其父命名空间被创建, 它也会被创建.</p>
                    <p>在一个命名空间的主体中, 可以结合this使用这三种方法, 这个时候, "路径" 是相对的.</p>
<pre class="vlight">
namespace_('vilic', function () {
    //this == vilic;
    var that = this;

    this.namespace_('alpha', function () {
        //this == vilic.alpha;
    });

    this.use_('alpha', function (alpha) {
        //this == that;
        //alpha == vilic.alpha;
    });

    //以 "." 开头的命名空间名表示绝对 "路径".
    this.use_('.vilic.alpha', function (alpha) {
        //this == that;
        //alpha == vilic.alpha;
    });

    this.require_('somefile.js', function (ns) {
        //this == that;
    });
});
</pre>
                    <p>"namespace_" 方法会传递怎样的参数呢? 如果存在的话, 它们会是该命名空间的父命名空间, 如下.</p>
<pre class="vlight">
namespace_('grand.parent.of.vilic', function (grand, parent, of) {
    //this == vilic;
	//grand == global.grand;
	//parent == grand.parent;
	//of == grand.parent.of;
});
</pre>
                </li>
                <li>
                    <b>use_(namespace : string [, namespace_args : string], body : function)</b><br />
                    <p>你可以同时使用一个或多个命名空间, 而这些命名空间会作为参数按顺序传递.</p>
<pre class="vlight">
use_('vilic.aaa', 'vilic.bbb', function (aaa, bbb) {
    //aaa == vilic.aaa;
    //bbb == vilic.bbb;
});
</pre>
                    <p>"use_" 方法并不会发送请求去获取文件. 如果相应的命名空间不存在, 它会将相关信息加入队列, 一旦相应命名空间被创建, 就会立即执行.</p>
                    <p>接下来, 这样用 "use_" 怎么样?</p>
<pre class="vlight">
use_('dom', 'dom.event').
namespace_('grand.parent.of.vilic', function (dom, event, grand, parent, of) {
    //this == vilic;
	//dom == global.dom;
	//event = dom.event;
	//grand == global.grand;
	//parent == grand.parent;
	//of == grand.parent.of;
});
</pre>
        </li>
                <li>
                    <b>require_(url : string [, url_args : string][, body : function])</b><br />
                    <p>"require_" 方法会尝试加载JS文件并执行它们, 其实, 它很像 "use_". 但是, 被加载的JS文件是有规范的. 它必须像这样书写.</p>
<pre class="vlight">
namespace_('somename', function () {
    //代码...
});
</pre>
                    <p>如果你只是想请求一个文件, 而不需要立即使用它, 你可以忽略回调函数, 之后再通过 "use_" 使用相应的命名空间.</p>
<pre class="vlight">
require_('somename.js');

//当你要使用它的时候, 使用 "use_".
use_('somename', function (somename) {
    //代码...
});
</pre>
                    <p>需要注意的是, "require_" 所请求的路径也是相对的, 如.</p>
<pre class="vlight">
//文件 "dir/file-a.js"
namespace('a', function () {
    //代码...
});

//文件 "dir/file-b.js"
namespace('b', function () {
    //请求文件 "file-a.js", 注意, 并没有 "dir/"
	this.require_('file-a.js');
});

//这是一个在根目录下执行的JS.
require_('dir/file-b.js');
</pre>
                </li>
            </ul>
            <p>有时候, 我们可能需要调试. 到现在为止, VEJIS这方面还很简陋. 但也不是过于简陋. 一方面, VEJIS通过处理错误的堆栈信息, 使得使用者可以更快速地定位到错误的真正位置. 另一方面, 你也可以使用 "vejis.status" 方法获取一些命名空间和文件请求的状态.</p>
<pre class="vlight">
//查看命名空间状态.
//VEJIS会输出如下格式的信息:
//状态 - 命名空间名称
//这里的 "状态" 可以是 "created(已创建)" 或者 "waiting(等待中)".
vejis.status('namespace');

//查看文件请求状态.
//VEJIS会输出如下格式的信息:
//状态 - 文件路径
//这里的 "状态" 可以是 "loaded(已加载)", "loading(正在加载)", "load error(加载时出错)" or "exec error(执行时出错)".
vejis.status('require');
</pre>
        </div>
        <div class="title">类的加强</div>
        <div class="content">
            <p>实际上, 这是老一些的VEJIS的核心功能. 而又在此之前, VEJIS是主打函数重载的, 但在现在的VEJIS中, 函数重载功能已经全部删除了. 但VEJIS对类的加强从来没有削减.</p>
            <p>VEJIS的类有如下特点.</p>
    	<ul>
        <li>
        	<b>基本的使用方式.</b><br />
<pre class="vlight">
var A = class_(function () {
	//定义构造函数.
	this._(function (value) {
    this.value = value;
	});

	//定义一个属性.
	this.value = 0;

	//定义一个方法.
	this.test = function () {
    alert(this.value);
	};
});

var a = new A(123);
//a.value == 123;

a.test(); //alert(123);
</pre>
        </li>
        <li>
        	<b>静态的公有和私有对象.</b><br />
<pre class="vlight">
var A = class_(function (pub, pri) {
	this.set = function (value) {
    pri.priValue = value || 456;
	};

	this.get = function () {
    return pri.priValue;
	};
}).static_(function () {
	//定义静态公有属性, 可选.
	this.public_({
    pubValue: 'pub'
	});

	//定义静态私有属性, 可选.
	this.private_({
    priValue: 'pri'
	});
});

//静态公有属性会被复制到 "A".
//A.pubValue == 'pub';

var a1 = new A();
var a2 = new A();

a1.set(123);
//a2.get() == 123;

//使用的时候, 如果你只需要静态的私有对象, 可以这样.
var C = class_(function (pub, pri) {
    //代码...
}).static_({
    priValue: 'pri'
});
</pre>
        	<p>你或许注意到了静态公有对象 "pub", 它和 "A", 也即对应的类之间并不完全等同. 实际上是当这个类是被继承的父类时, 会有不同. 但, 在类中, 我们应该总是使用 "pub" 而不是 "A" 去访问静态公有对象.</p>
        </li>
        <li>
        	<b>继承.</b><br />
<pre class="vlight">
var B = class_(function (pub, pri) {
	this.getFromB = function () { return pri.priValue; };
}).inherit_(A);

var a = new A();
var b = new B();

//分别从两个实例中调用在类 "A" 中定义的方法.
a.set(987);
b.set(789);

//a.get() == 987;
//b.get() == 789;
//b.getFromB() == 789;
</pre>
        	<p>这个例子展示了在 "A", "B" 两个类中, 静态私有对象的关系: <b>它们是互相独立的</b>. 静态公有对象也是如此. 所以, 不要担心你在子类对于这两个对象的更改会影响父类 (前提是, 你是使用的 "pub" 和 "pri").</p>
        </li>
    	</ul>
        </div>
        <div class="title">方法加强</div>
        <div class="content">
            <p>我是有点残忍了. 如今的方法加强并不再是VEJIS一个强大的功能. 你可以使用VEJIS来创建一个有静态对象的函数. 我知道它很简单.</p>
<pre class="vlight">
//传入的第一个参数就是静态对象, 它是私有的.
var fn = _(function (st, n) {
	console.log(st.count += n);
}).static_({
	count: 0
});

//这些值会被传入n.
fn(1);
fn(2);
</pre>
        </div>
        <div class="title">其他一些东西</div>
        <div class="content">
            <p>或许你注意到VEJIS的每一个方法都以 "_" 结尾, 我猜会有很多人不喜欢这种方式, 但或许他们以后就会了. 当VEJIS诞生的时候, 如之前提到的, 它的核心功能是函数重载. 我想找到一个简单明了的符号来创建VEJIS方法, 并且最终选择了 "_", 当时的语法就像是这样.</p>
<pre class="vlight">
//注意, 这个功能已经在现在的VEJIS中移除.
//至于为什么, 可能是重载代价比较大.

//创建一个VEJIS方法.
var fn = _(String, Number, function (str, num) {
    //代码...
});

//重载该方法.
fn._(Boolean, function (b) {
    //代码...
});
</pre>
            <p>实际上, 通过上面的函数重载, 就已经可以实现类的构造函数重载. 但有时, 我们需要改动的或许只有几行, 如果我们像上面那样使用, 整个构造函数都需要被重写. 所以我希望创建一个方法来解决这个问题. "class" 一词在JavaScript中是保留字, 所以我简单地在其后添加了后缀 "_", 让它变成了 "class_".</p>
            <p>因为VEJIS是针对 "语法层面" 加强的, 它的方法名很可能与关键字或者保留字冲突. 所以, 添加后缀 "_" 成为了VEJIS中方法的统一规范.</p>
        </div>
    </div>
    <div id="footer">©2011 VEJIS.ORG</div>
</div>


</body>
</html>
